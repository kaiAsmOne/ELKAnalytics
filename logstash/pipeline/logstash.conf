input {
  udp {
    port => 5140
    type => "syslog"
  }
}

# First i do an initial validation. Everything i want to log contains the word kernel.
# If the log entry does not contain the word kernel it will stop further processing. 
# Use this as an initial filter to filter what is relevant. Replace the word kernel on line 22 with what matches your own setup.
filter {
  if [type] == "syslog" {
    # First, parse just enough to identify if this is a kernel message
    grok {
      match => {
        "message" => "<%{POSINT:priority}>%{SYSLOGTIMESTAMP:timestamp} %{DATA:hostname} %{DATA:program}:"
      }
      tag_on_failure => ["_initial_grok_failure"]
    }
    
    # Drop non-kernel messages early to save processing
    if [program] != "kernel" {
      drop { }
    }

# This Grok Filter is made to match two different syslog message pattern:

# 1 for traffic initiated from public internet attemting to enter my network / connect to my public ip. (Message Priority 12)
#<12>Sep 19 13:15:55 mephisto-D167CB1-C kernel: DROP IN=eth0 OUT= MAC=04:42:1a:cd:5a:00:40:b4:f0:e0:5e:af:08:00 SRC=165.154.49.137 DST=139.48.125.218 LEN=44 TOS=0x00 PREC=0x00 TTL=44 ID=0 DF PROTO=TCP SPT=47436 DPT=9704 SEQ=1226283879 ACK=0 WINDOW=1024 RES=0x00 SYN URGP=0 OPT (02040584) MARK=0x8000000 

# 1 for traffic initiated from my LAN accessing services on the internet. (Message Priority 14)
#<14>Sep 19 13:13:16 mephisto-D167CB1-C kernel: OUT_CONN IN=br0 OUT=eth0 MAC=04:42:1a:cd:5a:00:ae:39:1a:67:9e:8f:08:00 SRC=192.168.50.6 DST=17.148.146.49 LEN=1228 TOS=0x02 PREC=0x00 TTL=63 ID=0 DF PROTO=UDP SPT=58473 DPT=443 LEN=1208 
    
    # Now parse the full firewall log format for kernel messages only
    grok {
      match => {
        "message" => "<%{POSINT:priority}>%{SYSLOGTIMESTAMP:timestamp} %{DATA:hostname} %{DATA:program}: %{DATA:action} IN=%{DATA:in_interface} OUT=(?<out_interface>\S*) MAC=(?<mac>\S*) SRC=%{IP:src_ip} DST=%{IP:dst_ip} LEN=%{INT:length} TOS=%{BASE16NUM:tos} PREC=%{BASE16NUM:prec} TTL=%{INT:ttl} ID=%{INT:id}(?: %{WORD:ip_flags})? PROTO=%{WORD:protocol}(?: SPT=%{INT:src_port} DPT=%{INT:dst_port})?(?: LEN=%{INT:udp_length})?(?: SEQ=%{INT:sequence} ACK=%{INT:ack} WINDOW=%{INT:window} RES=%{BASE16NUM:res} %{DATA:tcp_flags} URGP=%{INT:urgp})?(?: MARK=%{DATA:mark})?"
      }
      overwrite => [ "priority", "timestamp", "hostname", "program" ]
      tag_on_failure => ["_firewall_grok_failure"]
    }
    
    # Parse syslog timestamp
    date {
      match => [ "timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
      timezone => "Europe/Oslo"
      target => "@timestamp"
    }
    if ![@timestamp] {
    mutate {
      add_field => { "timestamp_with_year" => "%{+YYYY} %{timestamp}" }
    }
    date {
      match => [ "timestamp_with_year", "YYYY MMM dd HH:mm:ss", "YYYY MMM  d HH:mm:ss" ]
      timezone => "Europe/Oslo"
      target => "@timestamp"
    }
    mutate {
      remove_field => [ "timestamp_with_year" ]
    }
  }
    # Convert numeric fields to proper types
    mutate {
      convert => {
        "priority" => "integer"
        "length" => "integer"
        "ttl" => "integer"
        "id" => "integer"
        "src_port" => "integer"
        "dst_port" => "integer"
        "udp_length" => "integer"
        "sequence" => "integer"
        "ack" => "integer"
        "window" => "integer"
        "urgp" => "integer"
      }
    }
    
    # Enrich source IP with hostname
    # Add Hostname to IP Mappings as shown below to enrich logs with device name / friendly name
    translate {
      field => "src_ip"
      destination => "src_hostname"
      dictionary => {
        "192.168.1.100" => "SamsungTV"
        "192.168.1.120" => "MacBookPro"
      }
      fallback => "%{src_ip}"
    }
    
    # Enrich destination IP with hostname
    translate {
      field => "dst_ip"
      destination => "dst_hostname"
      dictionary => {
        "192.168.1.100" => "SamsungTV"
        "192.168.1.120" => "MacBookPro"
      }
      fallback => "%{dst_ip}"
    }
    
    # Create friendly traffic direction field
    if [src_hostname] != [src_ip] and [dst_hostname] != [dst_ip] {
      # Both have hostnames
      mutate {
        add_field => {
          "traffic_flow" => "%{src_hostname} -> %{dst_hostname}"
        }
      }
    } else if [src_hostname] != [src_ip] {
      # Only source has hostname
      mutate {
        add_field => {
          "traffic_flow" => "%{src_hostname} -> %{dst_ip}"
        }
      }
    } else if [dst_hostname] != [dst_ip] {
      # Only destination has hostname
      mutate {
        add_field => {
          "traffic_flow" => "%{src_ip} -> %{dst_hostname}"
        }
      }
    }
    
    # Add GeoIP enrichment for source IPs
    geoip {
      source => "src_ip"
      target => "src_geoip"
      tag_on_failure => ["_geoip_lookup_failure_src"]
    }
    
    # Add GeoIP for destination IPs
    geoip {
      source => "dst_ip"
      target => "dst_geoip"
      tag_on_failure => ["_geoip_lookup_failure_dst"]
    }
    
    # Create geo_point fields for Kibana maps
    if [src_geoip][location][lat] and [src_geoip][location][lon] {
      mutate {
        add_field => {
          "src_location" => "%{[src_geoip][location][lat]},%{[src_geoip][location][lon]}"
        }
      }
    }
    
    if [dst_geoip][location][lat] and [dst_geoip][location][lon] {
      mutate {
        add_field => {
          "dst_location" => "%{[dst_geoip][location][lat]},%{[dst_geoip][location][lon]}"
        }
      }
    }
  # Enrich with IP reputation from the ip-reputation index
  if [src_ip] !~ /^(192\.168\.|10\.|172\.(1[6-9]|2[0-9]|3[01])\.|127\.)/ {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      user => "logstash_system"
      password => "<YOUR_PW>"     
      index => "ip-reputation"
      query => "ip:%{src_ip}"
      fields => {
        "reputation_score" => "src_reputation_score"
        "threat_level" => "src_threat_level"
        "country" => "src_reputation_country"
        "as_owner" => "src_reputation_as_owner"
      }
      tag_on_failure => ["_src_reputation_not_found"]
    }
  }
  
  if [dst_ip] !~ /^(192\.168\.|10\.|172\.(1[6-9]|2[0-9]|3[01])\.|127\.)/ {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      user => "logstash_system"
      password => "<YOUR_PW>"      
      index => "ip-reputation"
      query => "ip:%{dst_ip}"
      fields => {
        "reputation_score" => "dst_reputation_score"
        "threat_level" => "dst_threat_level"
        "country" => "dst_reputation_country"
        "as_owner" => "dst_reputation_as_owner"
      }
      tag_on_failure => ["_dst_reputation_not_found"]
    }
  }
    
    # Add derived fields with conditionals to prevent literal strings
    if [protocol] and [dst_port] {
      mutate {
        add_field => {
          "traffic_direction" => "%{src_ip} -> %{dst_ip}:%{dst_port}"
          "protocol_port" => "%{protocol}/%{dst_port}"
        }
      }
    } else if [protocol] {
      mutate {
        add_field => {
          "traffic_direction" => "%{src_ip} -> %{dst_ip}"
          "protocol_port" => "%{protocol}"
        }
      }
    }
    
    # Tag common ports for easier filtering
    if [dst_port] == 22 {
      mutate { add_tag => ["ssh"] }
    } else if [dst_port] == 80 {
      mutate { add_tag => ["http"] }
    } else if [dst_port] == 443 {
      mutate { add_tag => ["https"] }
    } else if [dst_port] == 25 or [dst_port] == 587 or [dst_port] == 465 {
      mutate { add_tag => ["smtp"] }
    } else if [dst_port] == 3389 {
      mutate { add_tag => ["rdp"] }
    } else if [dst_port] == 21 {
      mutate { add_tag => ["ftp"] }
    } else if [dst_port] == 123 {
      mutate { add_tag => ["ntp"] }
    }
    
    # Add a tag to identify kernel/syslog messages
    mutate {
      add_tag => ["kernel", "syslog"]
    }
    
    # Remove the original message field to save space (optional)
    # mutate {
    #   remove_field => ["message"]
    # }
  }
}

output {
  # Only output to Elasticsearch if it's a kernel message (redundant check but ensures safety)
  if [program] == "kernel" {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      user => "logstash_system"
      password => "<YOUR_PW>"       
      index => "syslog-%{+YYYY.MM.dd}"  # Changed index name to be more specific
    }
  }
  
  # For debugging - only show kernel messages
  if [program] == "kernel" {
    stdout { codec => rubydebug }
  }
}
